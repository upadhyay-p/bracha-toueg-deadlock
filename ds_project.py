# -*- coding: utf-8 -*-
"""ds-project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nqGdnPjNcdcGKer9kM_tk94D6rM3CGK4
"""

import time
import sys
# !pip install mpi4py
from mpi4py import MPI
comm = MPI.COMM_WORLD
rank = comm.Get_rank()

import datetime
from collections import defaultdict

def addEdge(graph,u,v): 
      graph[u].append(v)

def setGraph(processId):
  file = open("input.txt","r")
  lines = file.readlines()
  numberOfNodes = 3
  initiator = int(lines[0])
  lines = lines[1:]

    
  # function for adding edge to graph 
  inEdges = defaultdict(list) 
  outEdges = defaultdict(list) 

  for i in lines:
    [u,v] = i.split(" ")
    u = int(u)
    v = int(v)
    addEdge(outEdges,u,v)
    addEdge(inEdges,v,u)

  myId=processId
  myIncomingEdges=[]
  myOutgoingEdges=[]
  if processId in inEdges:
    myIncomingEdges=inEdges[processId]
  if processId in outEdges:
    myOutgoingEdges=outEdges[processId]
  return numberOfNodes,initiator,myOutgoingEdges,myIncomingEdges

n,initiator,myOutgoingEdges,myIncomingEdges=setGraph(rank)

class Node:
  def __init__(self, id):
    self.id = id
    # self.LS=[None]*num_nodes
    self.outset = []
    self.inset = []
    self.time = datetime.datetime.now()
    self.p_requests=0
    self.blocked=False
    self.initiator = False
    self.weight=0
    self.init_id=0

  def setInitiator(self):
    self.initiator=True
    self.time= datetime.datetime.now()
    self.p_requests=len(myOutgoingEdges)
    self.outset=myOutgoingEdges
    self.blocked=True
    w=float(1/len(self.outset))
    print(self.outset)
    data={'source':rank,'init':rank,'t_init':self.time,'weight':w,'type':'FLOOD'}
    for neigh in self.outset:
      print(type(neigh))
      comm.send(data,neigh)

  def isDeadlockFree(self):
    pass

  def addOut(self,u):
    self.outset.append(u)
    self.p_requests+=1

  def addIn(self,u):
    self.inset.append(u)
  def receiveShort(self,source,init,t_init,weight):
    if t_init<self.time:
      return
    if t_init== self.time:
      if self.p_requests==0:
        return
      elif self.p_requests>0:
        if self.initiator:
          self.weight+=weight
          if self.weight==1:
            # print("deadlock detected")
            sys.exit("deadlock detected")
    
  def receiveEcho(self,source,init,t_init,weight):
    if(self.time>t_init):
      return
    elif self.time == t_init:
      self.outset.remove(source)
      if self.p_requests==0:
        data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'SHORT'}

        comm.send(data,init)
      elif self.p_requests>0:
        self.p_requests-=1
        if self.p_requests==0:
          init=rank
          print("No deadlock")
          weight1=float(weight/len(self.inset))
          data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight1,
                'type':'ECHO'}
          for k in myIncomingEdges:
            comm.send(data,k)
            sys.exit("No deadlock")
        else:
          data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'SHORT'}
          comm.send(data,init)





    
  def receiveFlood(self,source,init,t_init,weight):
    if(self.time>t_init):
      return
    

    elif self.time< t_init:
      if source in myIncomingEdges:
        self.outset=myOutgoingEdges
        self.inset={source}
        self.time=t_init
        self.p_requests=len(myOutgoingEdges)
        try:

          w=weight/len(myOutgoingEdges)
        except:
          pass
        if self.p_requests>0:
          data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':w,
                'type':'FLOOD'}
          for neigh in myOutgoingEdges:
               comm.send(data,neigh)
        elif self.p_requests==0:
          data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'ECHO'}
          comm.send(data,source)
          # self.outset=[]
            # self.inset.remove(source)

      else:
        data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'ECHO'}
        comm.send(data,source)

    elif self.time==t_init:
      if source not in myIncomingEdges:
        data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'ECHO'}
        comm.send(data,source)
      else:
        if self.p_requests==0:
           data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'ECHO'}
           comm.send(data,source)
        elif self.p_requests>0:
          data={'source':rank,
                'init':init,
                't_init':t_init,
                'weight':weight,
                'type':'SHORT'}
          comm.send(data,init)      
    

  # def checkDeadlock(self,id,LS,t,comm):
  #   LS[id].inset=[]
  #   LS[id].time=t
  #   LS[id].blocked=True
  #   w=float(1/len(LS[id].outset))
  #   for j in LS[id].outset:
  #     print(type(j.id))
  #     comm.send([w,MPI.FLOAT], int(j.id), tag="flood")
  #   t=time.time()
  #   receiveFlood(id,LS,t,comm)

LS={}
for i in range(n):
  LS[i] = Node(i)
  # LS[i].init_id=initiator

if rank==initiator:
	print(rank)
	LS[initiator].setInitiator()
 
while(True):
  if rank==initiator:
    if LS[initiator].weight==1:
      data={'source':rank,'init':rank,'t_init':self.time,'weight':1,'type':'TERMINATE'}
      print("b4 broadcast")
      comm.Bcast(data, root=rank)
  msg_recv=comm.recv(source=MPI.ANY_SOURCE)
  source=msg_recv['source']
  init=msg_recv['init']
  t_init=msg_recv['t_init']
  weight=msg_recv['weight']
  if(msg_recv['type']=="FLOOD"):
    LS[init].receiveFlood(source,init,t_init,weight)
  if(msg_recv['type']=="ECHO"):
    LS[init].receiveEcho(source,init,t_init,weight)
  if(msg_recv['type']=="SHORT"):
    LS[init].receiveShort(source,init,t_init,weight)
  if(msg_recv['type']=="TERMINATE"):
    sys.exit("Terminated")


# for i in lines:
# 	[u,v] = i.split(" ")
# 	u = int(u)
# 	v = int(v)
# 	# LS[u].addOut(LS[v])
# 	# LS[v].addIn(LS[u])
# 	addEdge(outEdges,u,v)
# 	addEdge(inEdges,v,u)

# LS[initiator].setInitiator(outEdges[initiator])

print(inEdges)
print(outEdges)
print(len(outEdges[initiator]))
print(LS[0].id)

#update input files for different timestamps
# LS[initiator].checkDeadlock(LS[initiator].id,LS,3,comm)

# ! mpiexec -np 4 python my-program-name.py



